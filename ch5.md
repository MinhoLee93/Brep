## 5장 나쁜 상황에 대비한 스프링 클라우드와 넷플릭스 히스트릭스의 클라이언트 회복성 패턴
> 기존 모놀리틱 서비스에서 성능 저하를 감지하고 우회하는 방법은 다음 이유로 매우 어려웠다.

1. 서비스 저하는 간한적으로 발생하고 확산 될 수 있다.
2. 원격 서비스 호출은 대개 동기식이며 오래 걸리는 호출을 중단하지 않는다.
3. 애플리케이션은 대개 부분적인 저하가 아닌 원격 자원의 완전한 장애를 처리하도록 설계된다.

```완전히 다운되지 않는 원격 서비스로 야기되는 문제의 심각성은 탐지하기 어려울 뿐만 아니라 애플리케이션 전체 생태계에 미치는 파급 효과가 크기 때문이다.```

### 5.1 클라이언트 회복성 패턴이란?
> 원격 서비스가 에러를 던지거나 제대로 동작하기 못해 원격 자원의 접근이 실패할 때, 원격 자원을 호출하는 클라이언트 충돌을 막는데 초점을 둔다.

``` 데이터베이스 커넥션 및 스레드 풀 같은 소중한 클라이언트 소비자에게 '상향' 전파되는 것을 막는 것을 목적으로 한다. (클라이언트 측에 구현)```

1. 클라이언트 측 부하 분산 : 가용 서비스 풀에서 문제가 된 인스턴스를 제거한다. (리본 default)
2. 회로 차단기 : 호출이 필요한 만큼 실패하면 회로 차단기가 활성화되어 빨리 실패하게 만들며, 고장 난 원격 자원은 더이상 호출되지 않도록 차단한다.
3. 폴백 : 원격 서비스에 대한 호출이 실패할 떄 예외를 발생시키지 않고, 서비스 소비자가 대체 코드 경로를 실행해 작업을 수행하게 한다.
4. 벌크헤드 : 원격 자원에 대한 호출을 자원별 스레드 풀로 분리하므로, 특정 원격 자원의 호출이 느려져 전체 애플리케이션이 다운될 수 있는 위험을 줄일 수 있다.

### 5.2 클라이언트 회복성이 중요한 이유?
> 책 p167~168

1. 원격 서비스에 문제가 있다는 것을 즉시 안다.
2. 대체 코드를 사용하는 조치를 취할 수 있다.
3. 문제 있는 원격 서비스가 복구할 수 있는 여유가 생긴다.

### 5.3 히스트릭스 시작
### 5.4 스프링 클라우드와 히스트릭스를 위한 서버 설정
1. add dependency
2. @EnableCircuitBreaker

### 5.5 히스트릭스를 사용한 회로 차단기 구현
> 히스트릭스 구현 방법은 다음 두가지 범주가 있다.

1. 본인 서비스의 데이터베이스에 대한 호출
2. 외부 서비스 사이의 호출

```히스트릭스는 원격 자원 사이에 존재하며 클라이언트를 보호한다. 즉, 데이터베이스를 호출하든 REST 기반 서비스를 호출하든 상관없다.```

### 5.6 폴백 프로세싱
### 5.7 벌크헤드 패턴 구현
### 5.8 히스트릭스 세부 설정

### 5.X Resilience4j (Spring Cloud CircuitBreaker)
> spring cloud 2020.0.0

1. Circuit Breaker
2. Rate Limit
3. Retry
4. BulkHead

### 5.9 스레드 컨텍스트와 히스트릭스