# 4. 서비스 디스커버리
> 분산 아키텍처에서 시스템의 물리적 위치 주소를 찾는 방법이며, 클라우드 기반 애플리케이션에서 중요한 이유는 다음과 같다.

1. 애플리케이션은 서비스 디스커버리를 사용해 해당 환경에서 실행하는 서비스 인스턴스 갯수를 신속하게 수평 확장하거나 축소할 수 있다.
2. 애플리케이션 회복성을 향상하는데 도움이 된다.

> 그렇다면.. 기존 DNS & Load Balancer 기반에 비해 나은점은 무엇이지..?

## 4.1 서비스 위치 찾기
> 클라우드 기반이 아닌 애플리케이션에서는 대개 DNS 와 Network Load Balancer 를 사용했다.

1. 클라이언트에게 요청을 받으면 로드 밸런서는 사용자가 액세스하려는 경로를 기반으로 라우팅 테이블에서 물리적 주소를 찾는다.
2. 애플리케이션 서버 갯수는 대개 정적이며 영구적인 경우가 많다. 
3. 애플리케이션 서버가 비정상적으로 종료하면, 종료 전과 동일한 상태와 동일한 IP 및 구성으로 복원된다. (오호)
4. 보조 로드 밸런서가 유휴 상태로 대기하고 주 로드 밸런서가 정상인지 핑으로 확인한다. 비정상일 경우 주 로드 밸런서의 IP 주소를 인수해 요청을 처리한다.

> 위와 같은 방식이 클라우드 기반의 마이크로 서비스 애플리케이션에서는 잘 동작하지 않는다. 이유는?

1. 단일 장애 지점 : 로드 밸런서가 다운되면 모든 애플리케이션이 다운된다. (eureka는?)
2. 수평 확장의 제약성 : 가변 모델이 아닌 고정 용량에 맞춘 한정된 라이센싱 모델이므로 수평 확장할 수 있는 능력에 제약이 있다.
3. 정적 관리 : 서비스를 신속히 등록하고 취소하도록 설계되지 않았다. 
4. 복잡성 : 새로운 인스턴스의 시작 시점이 아닌 수동으로 등록한다. (복잡성으로 인해..)

## 4.2 클라우드에서 서비스 디스커버리 
> 클라우드 기반 마이크로 서비스 환경에 대한 솔루션은 다음 기능을 갖춘 서비스 디스커버리 메커니즘을 사용한다.

1. 고가용성 : 서비스 검색 정보를 서비스 디스커버리 클러스터의 여러 노드가 공유하며, 한 노드가 사용할 수 없게 되면 다르 노드가 인계 받을 수 있어야 한다. 
2. 피어 투 피어 : 클러스터의 각 노드는 서비스 인스턴스의 상태를 공유한다.
3. 부하 분산 : 요청을 동적으로 부하 분산해서 관리하는 모든 인스턴스에 분배해야 한다.
4. 회복성 : 서비스 디스커버리 클라이언트는 서비스 정보를 로컬에 '캐시'해야 한다.
5. 장애 내성 : 서비스 인스턴스의 비정상을 탐지하고 가용 서비스 목록에서 인스턴스를 제거해야 한다.

#### 4.2.1 서비스 디스커버리 아키텍처
> 서비스 디스크버리 아키텍처 논의를 시작하려면 네 가지 개념을 이해해야 한다.

1. 서비스 등록
2. 클라이언트가 서비스 주소 검색
3. 정보 공유
4. 상태 모니터링

> 일반적으로 다음과 같은 순서로 서비스 디스커버리가 동작한다.

1. 서비스가 시작하고 자신의 물리적위치 / 경로 / 포트를 서비스 디스커버리에 등록한다. (1개의 서비스 디스커버리 인스턴스에만 등록하고 P2P 모델을 사용해 다른 노드에 전파한다.)
2. 클라이언트 측 부하 분산을 사용해 서비스를 호출한다.
- 서비스 소비자가 서비스 디스커버리 서비스에 접속해 데이터를 로컬에 캐시한다.
- 서비스를 호출하려고 할 떄마다 서비스 소비자는 캐시에서 위치를 검색해 '라운드 로빈' 으로 호출을 여러 인스턴스로 분산한다.
- 주기적으로 서비스 인스턴스 캐시를 새로고침 한다.


#### 4.2.2 스프링 넷플릭스 유레카를 사용한 서비스 디스커버리

## 4.3 스프링 유레카 서비스 구축

## 4.4 스프링 유레카 서비스 등록

## 4.5 서비스 디스커버리를 사용해 서비스 검색
> 서비스 인스턴스는 유레카를 사용하기 때문에 서로의 물리적 위치를 알지 못해도 호출할 수 있다.

소비자가 리본과 상호 작용할 수 있는 스프링/넷플릭스의 클라이언트 라이브러리 세 가지는 다음과 같다.

1. 스프링 디스커버리 클라이언트 (Discovery) : 표준 스프링 RestTemplate을 사용해 서비스 호출
2. RestTemplate이 활성화된 스프링 디스커버리 클라이언트 (Rest) : 향상된 스프링 RestTemplate을 사용해 리본 기반의 서비스를 호출한다.
3. 넷플릭스 Fegin 클라이언트 (Feign) : 넷플릭스 Feign 클라이언트를 사용해서 리본을 통해 서비스를 호출한다.

#### 4.5.1 스프링 DescoveryClient로 서비스 인스턴스 검색
> 리본과 등록된 서비스에 가장 저수준의 접근성을 제공한다.

1. 리본 클라이언트와 해당 URL 에 등록된 모든 서비스에 대해 질의할 수 있다.
2. @EnableDiscoveryClient 애너테이션을 사용해 DiscoveryClient 와 리본 라이브러리를 사용할 수 있다. (RestTemplate에 리본이 활성화된 인터셉터가 주입된다.)
3. 검색한 인스턴스를 사용해 대상 URL 을 조회 후 RestTemplate으로 서비스를 호출한다.

> 단점들..

1. 리본 클라이언트 측 부하 분산의 장점을 얻지 못한다 : 호출 서비스를 선택할 책임이 사용자에게 있다.
2. 너무 많은 일을 하고 있다 : 서비스 호출에 사용될 URL 을 직접 생성해야 한다. (귀찮고 번거롭다..)


#### 4.5.2 리본 지원 스프링 RestTemplate을 사용한 서비스 호출

1. @LoadBalanced 애너테이션으로 RestTemplate 빈 생성 메서드를 정의해야 한다.
2. Angel 릴리즈 이후 더이상 지원하지 않으므로, RestTemplate에서 리본을 사용하려면 @LoadBalanced 애너테이션을 직접 추가해야 한다.
3. URL에 포함된 서버 이름은 유레카에 등록할 때 사용된 조직 서비스 키의 애플리케이션 ID와 같다.


#### 4.5.3 넷플릭스 Fegin 클라이언트로 서비스 호출
> 인터페이스 정의한 후 리본이 호출할 유레카 기반의 서비스 매핑

1. 스프링 클라우드 프레임워크는 대상 REST 서비스를 호출하는 데 사용되는 프록시 클래스를 동적으로 생성.
2. 인터페이스 정의 외의 다른 코드 작성 필요 x
3. Feign 으로 반환하는 4xx - 5x 상태 코드는 FeignException 에 매핑된다.


